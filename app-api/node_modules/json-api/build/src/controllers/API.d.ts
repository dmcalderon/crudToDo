/// <reference types="node" />
/// <reference types="ramda" />
import R = require("ramda");
import { Request, FinalizedRequest, Result, HTTPResponse, ServerReq, ServerRes, Predicate, FieldConstraint, makeDocument, ErrorOrErrorArray } from "../types";
import Query from "../types/Query/Query";
import ResourceTypeRegistry from "../ResourceTypeRegistry";
import Document, { DocumentData } from "../types/Document";
import Resource from "../types/Resource";
import ResourceIdentifier from "../types/ResourceIdentifier";
import { TransformMode } from "../steps/make-transform-fn";
import { IncomingMessage, ServerResponse } from "http";
import CreateQuery from "../types/Query/CreateQuery";
import FindQuery from "../types/Query/FindQuery";
import UpdateQuery from "../types/Query/UpdateQuery";
import DeleteQuery from "../types/Query/DeleteQuery";
import AddToRelationshipQuery from "../types/Query/AddToRelationshipQuery";
import RemoveFromRelationshipQuery from "../types/Query/RemoveFromRelationshipQuery";
export { CreateQuery, FindQuery, UpdateQuery, DeleteQuery, AddToRelationshipQuery, RemoveFromRelationshipQuery, IncomingMessage, ServerResponse };
export declare type APIControllerOpts = {
    filterParser?: filterParamParser;
};
export declare type QueryFactory = (opts: QueryBuildingContext) => Query | Promise<Query>;
export declare type ResultFactory = (opts: ResultBuildingContext, customQueryFactory?: QueryFactory) => Result | Promise<Result>;
export declare type QueryBuildingContext = {
    request: FinalizedRequest;
    serverReq: ServerReq;
    serverRes: ServerRes;
    transformDocument: (doc: Document, mode: TransformMode) => Promise<Document>;
    setTypePaths: (it: (Resource | ResourceIdentifier)[], useInputData: boolean, requiredThroughType?: string) => Promise<void>;
    registry: ResourceTypeRegistry;
    makeDocument: makeDocument;
    makeQuery: QueryFactory;
};
export declare type ResultBuildingContext = QueryBuildingContext;
export declare type QueryTransformNoReq = {
    (first: Query): Query;
};
export declare type QueryTransformWithReq = {
    (first: ServerReq, second: Query): Query;
};
export declare type RequestOpts = {
    queryTransform?: QueryTransformNoReq | QueryTransformWithReq;
    queryFactory?: QueryFactory;
    resultFactory?: ResultFactory;
};
export declare type filterParamParser = (legalUnaryOpts: string[], legalBinaryOpts: string[], rawQuery: string | undefined, parsedParams: object) => (Predicate | FieldConstraint)[] | undefined;
export default class APIController {
    private registry;
    private filterParamParser;
    constructor(registry: ResourceTypeRegistry, opts?: APIControllerOpts);
    protected makeDoc: (data: DocumentData) => Document;
    protected finalizeRequest(request: Request): Promise<FinalizedRequest>;
    makeQuery(opts: QueryBuildingContext): Promise<CreateQuery | FindQuery | DeleteQuery | UpdateQuery | AddToRelationshipQuery | RemoveFromRelationshipQuery>;
    makeResult(opts: ResultBuildingContext, customQueryFactory?: QueryFactory): Promise<Result>;
    handle: (request: Request, serverReq: IncomingMessage, serverRes: ServerResponse, opts?: RequestOpts) => Promise<HTTPResponse>;
    static responseFromError(errors: ErrorOrErrorArray, requestAccepts: any): Promise<HTTPResponse>;
    static responseFromResult(result: Result, reqAccepts?: string, allow406?: boolean): Promise<HTTPResponse>;
    static supportedExt: ReadonlyArray<string>;
    static defaultFilterParamParser(legalUnary: any, legalBinary: any, rawQuery: any, params: any): (({
        operator: "eq" | "neq" | "ne";
        value: R.Ord;
    } & {
        field: string;
    }) | ({
        operator: "in" | "nin";
        value: string[] | number[];
    } & {
        field: string;
    }) | ({
        operator: "lt" | "gt" | "lte" | "gte";
        value: string | number;
    } & {
        field: string;
    }) | Predicate)[] | undefined;
}
